---
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2024-03-05
category:
  - 面试准备
tag:
  - 面试准备
star: true
sticky: true
---

# 1.Java&JVM

## 1.1.并发相关

### 1.1.1. ReentrantLock

#### 1.1.1.1. lock 接口

```code
1.公平锁流程:
  直接进入acquire方法，先执行tryAcquire：
    tryAcquire排队，然后cas状态是否直接可以上锁
    如果还是失败，再进队列，然后在acquireQueued方法中 for 循环，以及park等，具体路基如下
      再park中唤醒过来，如果我是头结点，并且执行tryAcquire成功就是上锁成功，执行过程中报异常，取消抢锁


2.非公平锁流程:
  1.cas判断当前状态是否没人使用,抢一下满足的直接上锁
  2.cas失败进入acquire方法,先执行tryAcquire：
    tryAcquire也是不排队，直接cas状态是否直接可以上锁
    如果还是失败，再进队列，然后在acquireQueued方法中 for 循环，以及park等，具体路基如下
      再park中唤醒过来，如果我是头结点，并且执行tryAcquire成功就是上锁成功，执行过程中报异常，取消抢锁

总结：公平锁和非公平的锁，上锁的区别就在tryAcquire方法上

```

### 1.1.2. 分布式ReentrantLock

```code
大致需要以下几方面:
1.以线程为单位
2.可重入
3.设置过期时间
4.发布订阅通知锁其他线程获取锁

-------------
1. lock 流程

2.tryLock流程:

3.unlock流程:

```

# 2.数据库(MySQL)

```code

```

# 3.Redis

```code

```

# 4.消息队列(Kafka、RocketMQ)

```code

```
